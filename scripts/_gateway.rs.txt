use axum::{extract::State, http::{HeaderMap, StatusCode}, response::IntoResponse, Json};
use uuid::Uuid;
use crate::{config::AppState, dlp};
#[derive(Clone)]
pub struct UpstreamClient { base: String, http: reqwest::Client }
impl UpstreamClient {
  pub fn new(base: String) -> Self { Self { base, http: reqwest::Client::new() } }
  pub async fn forward_chat(&self, body: serde_json::Value, auth: Option<&str>) -> Result<serde_json::Value, String> {
    let url = format!("{}/v1/chat/completions", self.base.trim_end_matches('/'));
    let mut r = self.http.post(url).json(&body);
    if let Some(a) = auth { r = r.header("Authorization", a); }
    let res = r.send().await.map_err(|e| e.to_string())?;
    if !res.status().is_success() { return Err(format!("upstream status {}", res.status())); }
    res.json::<serde_json::Value>().await.map_err(|e| e.to_string())
  }
}
pub async fn healthz() -> impl IntoResponse { (StatusCode::OK, "ok") }
pub async fn export_audit(State(st): State<AppState>) -> impl IntoResponse { (StatusCode::OK, st.ledger.export_all()) }
pub async fn chat_completions(State(st): State<AppState>, headers: HeaderMap, Json(req): Json<serde_json::Value>) -> impl IntoResponse {
  let request_id = Uuid::new_v4().to_string();
  let raw = serde_json::to_string(&req).unwrap_or_default();
  let findings = dlp::scan_text(&raw, &st.policy);
  st.ledger.append("prompt.scan", &request_id, serde_json::json!({"findings":findings}));
  let auth = headers.get("authorization").and_then(|v| v.to_str().ok());
  match st.upstream.forward_chat(req, auth).await {
    Ok(v) => (StatusCode::OK, Json(v)).into_response(),
    Err(_) => (StatusCode::BAD_GATEWAY, Json(serde_json::json!({"error":"upstream error","request_id":request_id}))).into_response()
  }
}